# خطة العمل المقسمة على مراحل - نظام SCADA

## نظرة عامة

تم تقسيم العمل على نظام المراقبة والتحكم (SCADA) إلى **6 مراحل** رئيسية، مع الالتزام الكامل بالقواعد الصارمة:

> ⚠️ **القواعد الصارمة:**
> - ❌ ممنوع البيانات الوهمية (Mock Data)
> - ❌ ممنوع Math.random() لتوليد قراءات
> - ✅ كل شاشة متصلة بـ API حقيقي
> - ✅ API متصل بقاعدة بيانات PostgreSQL
> - ✅ WebSocket للبيانات الحية متصل بمصدر حقيقي

---

## ما تم إنجازه حتى الآن ✅

### البنية الأساسية
- [x] Prisma Schema كامل مع جميع الجداول
- [x] Migration تم تطبيقها
- [x] قاعدة بيانات PostgreSQL تعمل
- [x] بيانات تجريبية (Seed Data)

### Backend (NestJS)
- [x] وحدة المحطات (Stations) - CRUD كامل
- [x] وحدة الأجهزة (Devices) - CRUD كامل
- [x] وحدة نقاط القياس (Data Points) - CRUD كامل
- [x] وحدة القراءات (Readings) - CRUD كامل
- [x] وحدة التنبيهات (Alarms) - CRUD + Acknowledge/Clear
- [x] وحدة أوامر التحكم (Commands) - CRUD كامل
- [x] WebSocket Gateway أساسي
- [x] Health Check Endpoint
- [x] Swagger Documentation

### Frontend (Angular)
- [x] Layout رئيسي مع RTL
- [x] Dashboard أساسي
- [x] قائمة وتفاصيل المحطات
- [x] قائمة وتفاصيل الأجهزة
- [x] قائمة التنبيهات مع التصفية
- [x] قائمة أوامر التحكم
- [x] صفحة التقارير (واجهة)

---

## المراحل المتبقية

---

## المرحلة 1: استكمال البيانات الأساسية

### الهدف
إضافة الجداول والـ APIs المتبقية في Prisma Schema

### المهام

#### 1.1 جدول القراءات المجمعة (ScadaReadingHourly)
```
المهمة: إنشاء جدول لتخزين القراءات المجمعة بالساعة للتقارير
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | إضافة model ScadaReadingHourly في schema.prisma | ⏳ |
| 2 | تشغيل prisma migrate | ⏳ |
| 3 | إنشاء ReadingsHourlyService في NestJS | ⏳ |
| 4 | إنشاء ReadingsHourlyController | ⏳ |
| 5 | اختبار API | ⏳ |

**APIs المطلوبة:**
```
GET /api/readings/hourly?deviceId=&dataPointId=&startDate=&endDate=
GET /api/readings/daily?deviceId=&dataPointId=&startDate=&endDate=
```

#### 1.2 جدول قواعد التنبيه (ScadaAlarmRule)
```
المهمة: إنشاء نظام قواعد التنبيه الديناميكية
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | التحقق من وجود الجدول في schema | ⏳ |
| 2 | إنشاء AlarmRulesService | ⏳ |
| 3 | إنشاء AlarmRulesController | ⏳ |
| 4 | إنشاء DTOs | ⏳ |
| 5 | اختبار CRUD | ⏳ |

**APIs المطلوبة:**
```
POST   /api/alarm-rules
GET    /api/alarm-rules
GET    /api/alarm-rules/:id
PUT    /api/alarm-rules/:id
DELETE /api/alarm-rules/:id
```

#### 1.3 جدول إعدادات الاتصال (ScadaConnection)
```
المهمة: إدارة إعدادات الاتصال بأجهزة Modbus
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | التحقق من وجود الجدول في schema | ⏳ |
| 2 | إنشاء ConnectionsService | ⏳ |
| 3 | إنشاء ConnectionsController | ⏳ |
| 4 | إنشاء DTOs | ⏳ |
| 5 | اختبار CRUD | ⏳ |

**APIs المطلوبة:**
```
GET    /api/connections
GET    /api/connections/:stationId
PUT    /api/connections/:stationId
POST   /api/connections/:stationId/test
```

### التسليمات
- [ ] 3 جداول جديدة في قاعدة البيانات
- [ ] 3 وحدات NestJS جديدة
- [ ] APIs مختبرة عبر Swagger

---

## المرحلة 2: خدمة جمع البيانات من Modbus

### الهدف
بناء خدمة لجمع البيانات من أجهزة Modbus TCP/RTU

### المهام

#### 2.1 تثبيت مكتبة Modbus
```bash
pnpm add jsmodbus serialport
```

#### 2.2 إنشاء ModbusCollectorService
```
المهمة: خدمة تقرأ البيانات من أجهزة Modbus وتحفظها
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | إنشاء ModbusModule | ⏳ |
| 2 | إنشاء ModbusTcpClient | ⏳ |
| 3 | إنشاء ModbusRtuClient | ⏳ |
| 4 | إنشاء ModbusCollectorService | ⏳ |
| 5 | إنشاء Scheduler لجمع البيانات | ⏳ |
| 6 | اختبار مع Modbus Simulator | ⏳ |

**الكود المتوقع:**
```typescript
@Injectable()
export class ModbusCollectorService {
  async collectReadings(stationId: string) {
    // 1. جلب إعدادات الاتصال
    // 2. الاتصال بالجهاز
    // 3. قراءة جميع نقاط القياس
    // 4. حفظ القراءات في قاعدة البيانات
    // 5. بث القراءات عبر WebSocket
    // 6. فحص التنبيهات
  }
}
```

#### 2.3 إنشاء Modbus Simulator (للاختبار)
```
المهمة: محاكي Modbus للاختبار في غياب أجهزة حقيقية
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | إنشاء ModbusSimulatorService | ⏳ |
| 2 | توليد قراءات واقعية (ليست عشوائية) | ⏳ |
| 3 | محاكاة سيناريوهات مختلفة | ⏳ |

### التسليمات
- [ ] خدمة Modbus TCP تعمل
- [ ] خدمة Modbus RTU تعمل
- [ ] Scheduler يجمع البيانات كل 5 ثواني
- [ ] محاكي للاختبار

---

## المرحلة 3: محرك التنبيهات والإشعارات

### الهدف
بناء نظام تنبيهات ذكي يعمل بناءً على القراءات الحية

### المهام

#### 3.1 محرك معالجة التنبيهات
```
المهمة: فحص القراءات وإنشاء تنبيهات تلقائياً
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | إنشاء AlarmEngineService | ⏳ |
| 2 | تنفيذ checkAlarms() | ⏳ |
| 3 | تنفيذ createAlarm() | ⏳ |
| 4 | تنفيذ autoClearAlarm() | ⏳ |
| 5 | اختبار مع قراءات حقيقية | ⏳ |

**منطق العمل:**
```typescript
async checkAlarms(dataPoint: DataPoint, value: number) {
  // فحص alarmHigh
  if (value > dataPoint.alarmHigh) → إنشاء تنبيه critical
  
  // فحص alarmLow
  if (value < dataPoint.alarmLow) → إنشاء تنبيه critical
  
  // فحص warningHigh
  if (value > dataPoint.warningHigh) → إنشاء تنبيه warning
  
  // فحص warningLow
  if (value < dataPoint.warningLow) → إنشاء تنبيه warning
  
  // مسح تلقائي إذا عادت القيمة للطبيعي
  if (القيمة طبيعية && يوجد تنبيه نشط) → مسح التنبيه
}
```

#### 3.2 نظام الإشعارات
```
المهمة: إرسال إشعارات فورية عند حدوث تنبيهات
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | إنشاء NotificationService | ⏳ |
| 2 | إشعارات WebSocket | ⏳ |
| 3 | إشعارات Email (اختياري) | ⏳ |
| 4 | إشعارات SMS (اختياري) | ⏳ |

#### 3.3 واجهة التنبيهات المتقدمة
```
المهمة: تحسين واجهة التنبيهات في Angular
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | صوت تنبيه للتنبيهات الحرجة | ⏳ |
| 2 | عداد التنبيهات في Header | ⏳ |
| 3 | تحديث تلقائي عبر WebSocket | ⏳ |
| 4 | تصفية متقدمة | ⏳ |

### التسليمات
- [ ] محرك تنبيهات يعمل تلقائياً
- [ ] إشعارات فورية عبر WebSocket
- [ ] واجهة تنبيهات محسنة

---

## المرحلة 4: لوحات المراقبة المتقدمة

### الهدف
بناء لوحات مراقبة تفاعلية مع رسوم بيانية وخرائط

### المهام

#### 4.1 Dashboard المحطة
```
المهمة: لوحة مراقبة شاملة لكل محطة
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | عرض جميع الأجهزة | ⏳ |
| 2 | القراءات الحية لكل جهاز | ⏳ |
| 3 | حالة القواطع (مفتوح/مغلق) | ⏳ |
| 4 | مؤشرات الأداء | ⏳ |

#### 4.2 الرسوم البيانية التاريخية
```
المهمة: رسوم بيانية تفاعلية للقراءات
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | تثبيت Chart.js أو ECharts | ⏳ |
| 2 | رسم بياني للجهد | ⏳ |
| 3 | رسم بياني للتيار | ⏳ |
| 4 | رسم بياني للقدرة | ⏳ |
| 5 | اختيار الفترة الزمنية | ⏳ |

#### 4.3 خريطة المحطات
```
المهمة: خريطة تفاعلية تعرض جميع المحطات
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | تثبيت Leaflet | ⏳ |
| 2 | عرض المحطات على الخريطة | ⏳ |
| 3 | ألوان حسب الحالة | ⏳ |
| 4 | Popup مع معلومات المحطة | ⏳ |

### التسليمات
- [ ] Dashboard محطة متكامل
- [ ] رسوم بيانية تفاعلية
- [ ] خريطة المحطات

---

## المرحلة 5: التحكم عن بُعد

### الهدف
نظام تحكم آمن مع موافقات للأوامر الحرجة

### المهام

#### 5.1 نظام الموافقات
```
المهمة: أوامر التحكم الحرجة تتطلب موافقة
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | تحديد الأوامر التي تتطلب موافقة | ⏳ |
| 2 | إنشاء ApprovalService | ⏳ |
| 3 | إنشاء واجهة الموافقات | ⏳ |
| 4 | إشعار المشرف عند طلب موافقة | ⏳ |

#### 5.2 تنفيذ الأوامر
```
المهمة: إرسال الأوامر للأجهزة عبر Modbus
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | إنشاء CommandExecutorService | ⏳ |
| 2 | كتابة قيم Modbus | ⏳ |
| 3 | التحقق من التنفيذ | ⏳ |
| 4 | تسجيل في سجل الأحداث | ⏳ |

#### 5.3 واجهة التحكم
```
المهمة: واجهة لإرسال أوامر التحكم
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | نموذج إرسال أمر | ⏳ |
| 2 | تأكيد قبل الإرسال | ⏳ |
| 3 | عرض حالة التنفيذ | ⏳ |
| 4 | سجل الأوامر | ⏳ |

### التسليمات
- [ ] نظام موافقات يعمل
- [ ] تنفيذ أوامر عبر Modbus
- [ ] واجهة تحكم آمنة

---

## المرحلة 6: التقارير والتحليلات

### الهدف
تقارير شاملة ومؤشرات أداء

### المهام

#### 6.1 تقارير الأداء
```
المهمة: تقارير أداء المحطات والأجهزة
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | تقرير ملخص المحطة | ⏳ |
| 2 | تقرير استهلاك الطاقة | ⏳ |
| 3 | تقرير التوافرية | ⏳ |
| 4 | تصدير PDF/Excel | ⏳ |

#### 6.2 تقارير التنبيهات
```
المهمة: تحليل التنبيهات والأعطال
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | ملخص التنبيهات بالفترة | ⏳ |
| 2 | أكثر الأجهزة أعطالاً | ⏳ |
| 3 | متوسط وقت الاستجابة | ⏳ |
| 4 | رسوم بيانية للتنبيهات | ⏳ |

#### 6.3 مؤشرات KPI
```
المهمة: لوحة مؤشرات الأداء الرئيسية
```

| الخطوة | الوصف | الحالة |
|--------|-------|--------|
| 1 | نسبة التوافرية | ⏳ |
| 2 | معدل الأعطال | ⏳ |
| 3 | كفاءة الاستجابة | ⏳ |
| 4 | استهلاك الطاقة | ⏳ |

### التسليمات
- [ ] 4 أنواع تقارير
- [ ] تصدير PDF/Excel
- [ ] لوحة KPI

---

## ملخص المراحل

| المرحلة | الوصف | المدة المتوقعة | الأولوية |
|---------|-------|----------------|----------|
| **1** | استكمال البيانات الأساسية | 2-3 ساعات | عالية |
| **2** | خدمة جمع البيانات من Modbus | 4-5 ساعات | عالية |
| **3** | محرك التنبيهات والإشعارات | 3-4 ساعات | عالية |
| **4** | لوحات المراقبة المتقدمة | 4-5 ساعات | متوسطة |
| **5** | التحكم عن بُعد | 3-4 ساعات | متوسطة |
| **6** | التقارير والتحليلات | 4-5 ساعات | متوسطة |

---

## تسلسل البناء لكل مكون

```
┌─────────────────────────────────────────────────────┐
│ 1. إنشاء/تحديث الجدول في Prisma Schema             │
│ 2. تشغيل Migration                                  │
│ 3. إنشاء NestJS Service + Controller               │
│ 4. اختبار API عبر Swagger                          │
│ 5. إنشاء Angular Component                         │
│ 6. ربط Component بالـ API                          │
│ 7. اختبار ببيانات حقيقية                           │
│ 8. ← المكون مكتمل ✅                                │
└─────────────────────────────────────────────────────┘
```

---

## الخطوة التالية

**هل تريد البدء بالمرحلة 1؟**

سأقوم بـ:
1. إضافة جدول ScadaReadingHourly
2. إنشاء وحدة AlarmRules
3. إنشاء وحدة Connections
4. اختبار جميع APIs

---

**تاريخ إنشاء الخطة**: 18 ديسمبر 2025
